#! /usr/bin/env python

import ctypes, imp

module, path, description = imp.find_module("SimulatorTest", ["test_files", "../.."])
mod = imp.load_module("SimulatorTest", module, path, description)

class ALUTest(mod.SimulatorTest):        
        
    # Don't bother executing until idle before starting this test.
    def initialExecution(self):
        # Wait 60 cycles until initialisation program finishes
        self.wait(60)

    def runTest(self):
        bigNum = 0x12345678
        
        # Addition, subtraction, simple multiplication.
        self.execute(0, "lli r10 " + str(bigNum & 0xFFFF))
        self.execute(0, "lui r10 " + str(bigNum >> 16))
        self.execute(0, "subu  r11 r0 r10")
        self.execute(0, "addui r22 r0 -1")
        self.execute(0, "mullw r12 r11 r22")
        self.assertEqual(bigNum,  self.readReg(0,10), "addui")
        self.assertEqual(-bigNum, self.readReg(0,11), "subu")
        self.assertEqual(bigNum,  self.readReg(0,12), "mullw")
        
        # Multiplication with long results.
        # Not 100% confident that the test for mulhwu is correct, because
        # various sources disagree with what the result should be.
        # Assuming 1C00000000000000 (Ubuntu calculator, simulator, Python)
        # Might be 0C00000000000000 (WolframAlpha)
        self.execute(0, "mullw r13 r10 r10")
        self.execute(0, "mulhw r14 r10 r10")
        self.execute(0, "mullw r12 r10 r11")
        self.execute(0, "mulhwu r15 r10 r11")
        
        # Need to convert any necessary values to unsigned representations.
        reg12 = ctypes.c_uint32(self.readReg(0,12)).value
        reg13 = ctypes.c_uint32(self.readReg(0,13)).value
        reg15 = ctypes.c_uint32(self.readReg(0,15)).value
        unsignedExpected = ctypes.c_uint32(-bigNum).value * bigNum
        signedResult = (self.readReg(0,14)<<32)|(reg13)
        unsignedResult = (reg15<<32)|(reg12)
        
        self.assertEqual(bigNum ** 2, signedResult, "mulhw")
        self.assertEqual(unsignedExpected, unsignedResult, "mulhwu")
        
        # Bitwise operations.
        r25 = 0x00FF
        r26 = 0x0FF0
        self.execute(0, "lli r25 "+str(r25))
        self.execute(0, "lli r26 "+str(r26))
        self.execute(0, "or  r27 r25 r26")
        self.execute(0, "and r28 r25 r26")
        self.execute(0, "nor r29 r25 r26")
        self.execute(0, "xor r12 r25 r26")
        self.assertEqual(  r25 |  r26,  self.readReg(0,27), "or")
        self.assertEqual(  r25 &  r26,  self.readReg(0,28), "and")
        self.assertEqual(~(r25 |  r26), self.readReg(0,29), "nor")
        self.assertEqual(  r25 ^  r26,  self.readReg(0,12), "xor")
        
        # Other.
        
        # Population count is no longer supported
        #self.execute(0, "popc r25 r10")
        #self.assertEqual(bin(bigNum).count('1'), self.readReg(0,25), "popc")
        
        
if __name__ == '__main__':
    ALUTest().runAllTests()
