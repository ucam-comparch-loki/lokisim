% 1D DCT along rows

% Prologue: connect to data memories
ori         r0,  r0,  112 > (13,3)  ; connect to memory to read input image and DCT weights
ori         r0,  r0,  112 > (14,3)  ; connect to memory to write intermediate image
ori         r22, r0,  11585         ; store a value we need

% Initialisation: receive parameters
or          r20, ch0, r0            ; wait for location of input block
or          r21, ch0, r0            ; wait for location of output block

and         r2,  r2,  r0            ; current row = 0
and         r3,  r3,  r0            ; current column = 0
and         r4,  r4,  r0            ; index of current weight = 0 (k)
and         r5,  r5,  r0            ; DCT output = 0 (f_val)
and         r6,  r6,  r0            ; values added to output so far = 0 (i)

% Inner loop
sll         r7,  r2,  3             ; current row * 8 = index of start of row
addu        r8,  r7,  r6            ; r7 now contains the position in the block of the pixel we want
sll         r8,  r8,  2             ; shift to get a byte address
addu        r8,  r8,  r20           ; r8 now holds the location of the pixel in memory
ld          r8,  0        > (13,0)  ; load the pixel (perhaps use ldb?)
ld          r4,  0        > (13,0)  ; load the weight for this pixel
or          r8,  ch1, r0            ; store whichever value arrives first
mullw       r8,  ch1, r8            ; multiply by the value which arrives second
addu        r5,  r5,  r8            ; add to the output (warning - may not be unsigned)
addui       r6,  r6,  1             ; increment values added
seqi.p      r0,  r6,  8             ; set predicate if we've added 8 values
addui       r4,  r4,  4             ; move to the next weight (filling predicate delay slot)
!p?ibjmp    -48                     ; restart loop if we're not finished

snei.p      r0,  r3,  0             ; set predicate if we are not in the first column
addu        r8,  r7,  r3            ; position in block to write to
sll         r8,  r8,  2             ; shift so we get a byte position
addu        r8,  r8,  r21           ; memory location to write to
p?or        r9,  r5,  r0            ; want to write sum relatively unchanged
!p?srl      r9,  r5,  14            ; need to do some fancy tricks with the sum
!p?mullw    r9,  r9,  r22
srl         r9,  r9,  15            ; the shift is common to both branches
st          r9,  r8,  0   > (14,0)  ; store the value

addui       r3,  r3,  1             ; increment current column
seqi.p      r0,  r3,  8             ; set predicate if we've finished all 8 columns in this row
nop
!p?ibjmp    -108                    ; jump back to start of loop (f_val = 0)

addui       r2,  r2,  1             ; increment current row
seqi.p      r0,  r2,  8             ; set predicate if we've finished all 8 rows
nop
!p?ibjmp    -132                    ; jump back to start of loop (column = 0)

or          r0,  r21, r0  > (2,2)   ; send a pointer to the output block to the next core
ibjmp.eop   -152                    ; jump to beginning (wait for input)


% 1D DCT along columns
% Note: instead of using this, the results of the first 1D DCT could be
% transposed, and fed back into the same 1D DCT.
% This might save a little code, but would probably use more cores, without
% speeding up execution.

% Prologue: connect to data memories
ori         r0,  r0,  177 > (14,3)  ; connect to memory to read intermediate image
ori         r0,  r0,  177 > (13,3)  ; connect to memory to read DCT weights
ori         r0,  r0,  176 > (15,3)  ; connect to memory to write output
ori         r22, r0,  11585         ; store a value we need

% Initialisation: receive parameters
or          r20, ch0, r0            ; wait for location of input/output block

and         r2,  r2,  r0            ; current column = 0
and         r3,  r3,  r0            ; current row = 0
and         r4,  r4,  r0            ; index of current weight = 0 (k)
and         r5,  r5,  r0            ; DCT output = 0 (f_val)
and         r6,  r6,  r0            ; values added to output so far = 0 (i)

% Inner loop
sll         r7,  r6,  3             ; current row * 8 = index of start of row
addu        r8,  r7,  r2            ; r7 now contains the position in the block of the pixel we want
sll         r8,  r8,  2             ; shift to get a byte address
addu        r8,  r8,  r20           ; r8 now holds the location of the pixel in memory
ld          r8,  0        > (14,1)  ; load the pixel (perhaps use ldb?)
ld          r4,  0        > (13,1)  ; load the weight for this pixel
or          r8,  ch1, r0            ; store whichever value arrives first
mullw       r8,  ch1, r8            ; multiply by the value which arrives second
addu        r5,  r5,  r8            ; add to the output (warning - may not be unsigned)
addui       r6,  r6,  1             ; increment values added
seqi.p      r0,  r6,  8             ; set predicate if we've added 8 values
addui       r4,  r4,  4             ; move to the next weight (filling predicate delay slot)
!p?ibjmp    -48                     ; restart loop if we're not finished

snei.p      r0,  r3,  0             ; set predicate if we are not in the first row
sll         r8,  r3,  3             ; position of start of current row
addu        r8,  r3,  r2            ; position in block to write to
sll         r8,  r8,  2             ; shift so we have a byte position
addu        r8,  r8,  r20           ; memory location to write to
p?or        r9,  r5,  r0            ; want to write sum relatively unchanged
!p?srl      r9,  r5,  14            ; need to do some fancy tricks with the sum
!p?mullw    r9,  r9,  r22
srl         r9,  r9,  15            ; the shift is common to both branches
st          r9,  r8,  0   > (15,0)  ; store the value

addui       r3,  r3,  1             ; increment current row
seqi.p      r0,  r3,  8             ; set predicate if we've finished all 8 rows in this column
nop
!p?ibjmp    -112                    ; jump back to start of loop (f_val = 0)

addui       r2,  r2,  1             ; increment current column
seqi.p      r0,  r2,  8             ; set predicate if we've finished all 8 columns
nop
!p?ibjmp    -136                    ; jump back to start of loop (row = 0)

ibjmp.eop   -148                    ; jump to beginning (wait for input)
