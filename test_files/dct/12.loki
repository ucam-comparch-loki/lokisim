% 1D DCT along rows

% Prologue: connect to data memories
ori         r0,  r0,  112 > (13,3)  ; connect to memory to read input image and DCT weights
ori         r0,  r0,  112 > (14,3)  ; connect to memory to write intermediate image
ori         r22, r0,  11585         ; store a value we need

% Initialisation: receive parameters
or          r20, ch0, r0            ; wait for location of input block
or          r21, ch0, r0            ; wait for location of output block

and         r10, r10, r0            ; current row = 0
and         r11, r11, r0            ; current column = 0
and         r12, r12, r0            ; index of current weight = 0 (k)
and         r13, r13, r0            ; DCT output = 0 (f_val)
and         r14, r14, r0            ; values added to output so far = 0 (i)

% Inner loop
sll         r15, r10, 3             ; current row * 8 = index of start of row
addu        r16, r15, r14           ; r15 now contains the position in the block of the pixel we want
addu        r16, r16, r20           ; r16 now holds the location of the pixel in memory
ld          r16, 0        > (13,0)  ; load the pixel (perhaps use ldb?)
ld          r12, 0        > (13,0)  ; load the weight for this pixel
and         r16, ch1, r0            ; store whichever value arrives first
mullw       r16, ch1, r16           ; multiply by the value which arrives second
addu        r13, r13, r16           ; add to the output (warning - may not be unsigned)
addui       r14, r14, 1             ; increment values added
seqi.p      r0,  r14, 8             ; set predicate if we've added 8 values
addui       r12, r12, 1             ; move to the next weight (filling predicate delay slot)
!p?ibjmp    -11                     ; restart loop if we're not finished

snei.p      r0,  r11, 0             ; set predicate if we are not in the first column
addu        r16, r15, r11           ; position in block to write to
addu        r16, r16, r21           ; memory location to write to
p?or        r17, r13, r0            ; want to write sum relatively unchanged
!p?srl      r17, r13, 14            ; need to do some fancy tricks with the sum
!p?mullw    r17, r17, r22
srl         r17, r17, 15            ; the shift is common to both branches
st          r17, r16, 0   > (14,0)  ; store the value
nop                                 ; store delay slot -- bug or feature?

addui       r11, r11, 1             ; increment current column
seqi.p      r0,  r11, 8             ; set predicate if we've finished all 8 columns in this row
nop
!p?ibjmp    -27                     ; jump back to start of loop (k = 0)

addui       r10, r10, 1             ; increment current row
seqi.p      r0,  r10, 8             ; set predicate if we've finished all 8 rows
nop
!p?ibjmp    -32                     ; jump back to start of loop (column = 0)

or          r0,  r21, r0  > (2,2)   ; send a pointer to the output block to the next core
ibjmp.eop   -37                     ; jump to beginning (wait for input)


% 1D DCT along columns
% Note: instead of using this, the results of the first 1D DCT could be
% transposed, and fed back into the same 1D DCT.
% This might save a little code, but would probably use more cores.

% Prologue: connect to data memories
ori         r0,  r0,  177 > (14,3)  ; connect to memory to read intermediate image
ori         r0,  r0,  177 > (13,3)  ; connect to memory to read DCT weights
ori         r0,  r0,  176 > (15,3)  ; connect to memory to write output
ori         r22, r0,  11585         ; store a value we need

% Initialisation: receive parameters
or          r20, ch0, r0            ; wait for location of input/output block

and         r10, r10, r0            ; current column = 0
and         r11, r11, r0            ; current row = 0
and         r12, r12, r0            ; index of current weight = 0 (k)
and         r13, r13, r0            ; DCT output = 0 (f_val)
and         r14, r14, r0            ; values added to output so far = 0 (i)

% Inner loop
sll         r15, r14, 3             ; current row * 8 = index of start of row
addu        r16, r15, r10           ; r15 now contains the position in the block of the pixel we want
addu        r16, r16, r20           ; r16 now holds the location of the pixel in memory
ld          r16, 0        > (14,1)  ; load the pixel (perhaps use ldb?)
ld          r12, 0        > (13,1)  ; load the weight for this pixel
and         r16, ch1, r0            ; store whichever value arrives first
mullw       r16, ch1, r16           ; multiply by the value which arrives second
addu        r13, r13, r16           ; add to the output (warning - may not be unsigned)
addui       r14, r14, 1             ; increment values added
seqi.p      r0,  r14, 8             ; set predicate if we've added 8 values
addui       r12, r12, 1             ; move to the next weight (filling predicate delay slot)
!p?ibjmp    -11                     ; restart loop if we're not finished

snei.p      r0,  r11, 0             ; set predicate if we are not in the first row
sll         r16, r11, 3             ; position of start of current row
addu        r16, r11, r10           ; position in block to write to
addu        r16, r16, r20           ; memory location to write to
p?or        r17, r13, r0            ; want to write sum relatively unchanged
!p?srl      r17, r13, 14            ; need to do some fancy tricks with the sum
!p?mullw    r17, r17, r22
srl         r17, r17, 15            ; the shift is common to both branches
st          r17, r16, 0   > (15,0)  ; store the value
nop                                 ; store delay slot -- bug or feature?

addui       r11, r11, 1             ; increment current row
seqi.p      r0,  r11, 8             ; set predicate if we've finished all 8 rows in this column
nop
!p?ibjmp    -28                     ; jump back to start of loop (k = 0)

addui       r10, r10, 1             ; increment current column
seqi.p      r0,  r10, 8             ; set predicate if we've finished all 8 columns
nop
!p?ibjmp    -33                     ; jump back to start of loop (row = 0)

ibjmp.eop   -36                     ; jump to beginning (wait for input)
