% 1D DCT along rows

% Prologue: connect to data memories
ori         r0,  r0,  (1,2) > 2     ; connect to memory to write intermediate image
ori         r0,  r0,  (1,3) > 1     ; connect to memory to read input image and DCT weights
ori         r29, r0,  11585         ; store a value we need

% Initialisation: receive parameters
or          r30, ch0, r0            ; wait for location of input block
or          r31, ch0, r0            ; wait for location of output block

and         r2,  r2,  r0            ; current row = 0
and         r3,  r3,  r0            ; current column = 0
and         r4,  r4,  r0            ; index of current weight = 0 (k)
and         r5,  r5,  r0            ; DCT output = 0 (f_val)
and         r6,  r6,  r0            ; values added to output so far = 0 (i)

% Inner loop
slli        r7,  r2,  3             ; current row * 8 = index of start of row
addu        r8,  r7,  r6            ; r7 now contains the position in the block of the pixel we want
slli        r8,  r8,  2             ; shift to get a byte address
addu        r8,  r8,  r30           ; r8 now holds the location of the pixel in memory
ldw         r8,  0        > 1       ; load the pixel (perhaps use ldb?)
ldw         r4,  0        > 1       ; load the weight for this pixel
or          r8,  ch1, r0            ; store whichever value arrives first
mullw       r8,  ch1, r8            ; multiply by the value which arrives second
addu        r5,  r5,  r8            ; add to the output
addui       r6,  r6,  1             ; increment values added
seteqi.p    r0,  r6,  8             ; set predicate if we've added 8 values
addui       r4,  r4,  4             ; move to the next weight (filling predicate delay slot)
!p?ibjmp    -48                     ; restart loop if we're not finished

setnei.p    r0,  r3,  0             ; set predicate if we are not in the first column
addu        r8,  r7,  r3            ; position in block to write to
slli        r8,  r8,  2             ; shift so we get a byte position
addu        r8,  r8,  r31           ; memory location to write to
p?or        r9,  r5,  r0            ; if p, want to write sum relatively unchanged
!p?srai     r9,  r5,  14            ; else, need to do some fancy tricks with the sum
!p?mullw    r9,  r9,  r29
srai        r9,  r9,  15            ; the shift is common to both branches
stw         r9,  r8,  0   > 2       ; store the value

addui       r3,  r3,  1             ; increment current column
seteqi.p    r0,  r3,  8             ; set predicate if we've finished all 8 columns in this row
!p?ibjmp    -104                    ; jump back to start of loop (f_val = 0)

addui       r2,  r2,  1             ; increment current row
seteqi.p    r0,  r2,  8             ; set predicate if we've finished all 8 rows
nop                                ;  can't remove this nop for some reason
!p?ibjmp    -128                    ; jump back to start of loop (column = 0)

or          r0,  r31, r0  > 3       ; send a pointer to the output block to the next core
ibjmp.eop   -148                    ; jump to beginning (wait for input)


% 1D DCT along columns
% Note: instead of using this, the results of the first 1D DCT could be
% transposed, and fed back into the same 1D DCT.
% This might save a little code, but would probably use more cores, without
% speeding up execution.

% Prologue: connect to data memories
ori         r0,  r0,  (2,3) > 3     ; connect to memory to write output
ori         r0,  r0,  (2,2) > 2     ; connect to memory to read intermediate image
ori         r0,  r0,  (2,3) > 1     ; connect to memory to read DCT weights
ori         r29, r0,  11585         ; store a value we need

% Initialisation: receive parameters
or          r30, ch0, r0            ; wait for location of input/output block

and         r2,  r2,  r0            ; current column = 0
and         r3,  r3,  r0            ; current row = 0
and         r4,  r4,  r0            ; index of current weight = 0 (k)
and         r5,  r5,  r0            ; DCT output = 0 (f_val)
and         r6,  r6,  r0            ; values added to output so far = 0 (i)

% Inner loop
slli        r7,  r6,  3             ; current row * 8 = index of start of row
addu        r8,  r7,  r2            ; r7 now contains the position in the block of the pixel we want
slli        r8,  r8,  2             ; shift to get a byte address
addu        r8,  r8,  r30           ; r8 now holds the location of the pixel in memory
ldw         r8,  0        > 2       ; load the pixel (perhaps use ldb?)
ldw         r4,  0        > 1       ; load the weight for this pixel
or          r8,  ch0, r0            ; store whichever value arrives first
mullw       r8,  ch1, r8            ; multiply by the value which arrives second
addu        r5,  r5,  r8            ; add to the output
addui       r6,  r6,  1             ; increment values added
seteqi.p    r0,  r6,  8             ; set predicate if we've added 8 values
addui       r4,  r4,  4             ; move to the next weight (filling predicate delay slot)
!p?ibjmp    -48                     ; restart loop if we're not finished

setnei.p    r0,  r3,  0             ; set predicate if we are not in the first row
slli        r8,  r3,  3             ; position of start of current row
addu        r8,  r8,  r2            ; position in block to write to
slli        r8,  r8,  2             ; shift so we have a byte position
addu        r8,  r8,  r30           ; memory location to write to
p?or        r9,  r5,  r0            ; if p, want to write sum relatively unchanged
!p?srai     r9,  r5,  14            ; else, need to do some fancy tricks with the sum
!p?mullw    r9,  r9,  r29
srai        r9,  r9,  15            ; the shift is common to both branches
stw         r9,  r8,  0   > 3       ; store the value

addui       r3,  r3,  1             ; increment current row
seteqi.p    r0,  r3,  8             ; set predicate if we've finished all 8 rows in this column
!p?ibjmp    -108                    ; jump back to start of loop (f_val = 0)

addui       r2,  r2,  1             ; increment current column
seteqi.p    r0,  r2,  8             ; set predicate if we've finished all 8 columns
!p?ibjmp    -128                    ; jump back to start of loop (row = 0)

ibjmp.eop   -140                    ; jump to beginning (wait for input)
