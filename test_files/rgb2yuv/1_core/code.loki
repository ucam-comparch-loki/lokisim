% RGB to YUV (technically YCbCr) colour space conversion
%
% Reads RGB data from three separate arrays, and outputs YUV data to three
% separate arrays. Each value is one byte long.
%
%   Y = (( 66R + 129G +  25B + 128) >> 8) + 16
%   U = ((-38R -  74G + 112B + 128) >> 8) + 128
%   V = ((112R -  94G -  18B + 128) >> 8) + 128

% Set up connections to memories
fetch               r1,  28
ori                 r5,  r0,  (13,0)
ori                 r6,  r0,  (14,0)
setchmap            r5,  1                  ; input = map 1
setchmap            r6,  2                  ; output = map 2
ori                 r0,  r0,  (0,2)  > 1
ori.eop             r0,  r0,  (0,0)  > 2

% Load parameters
fetch               r1,  36
ldw                 r0,  4           > 1
ldw                 r0,  8           > 1
ori                 r2,  ch0, 0             ; r2 = rows of input
ori                 r3,  ch0, 0             ; r3 = columns of input
mullw               r4,  r3,  r2            ; r4 = length of input

% Initialisation
ori                 r5,  r4,  0             ; r5 = start of second input (green)
addu                r6,  r5,  r5            ; r6 = start of third input (blue)
ori.eop             r10, r0,  0             ; r10 = current location

% Start of loop
% Load subpixel values
fetch               r1,  36
ldbu                r10, 12          > 1    ; load red (offset = length of params)
addu                r11, r5,  r10           ; r11 = position in green array
ldbu                r11, 12          > 1    ; load green
addu                r12, r6,  r10           ; r12 = position in blue array
ldbu                r12, 12          > 1    ; load blue
ori                 r7,  ch0, 0             ; r7 = red
ori                 r8,  ch0, 0             ; r8 = green
ori.eop             r9,  ch0, 0             ; r9 = blue

% Compute Y
fetch               r1,  100
ori                 r13, r0,  66            ; store coefficient
ori                 r14, r0,  129           ; store coefficient
ori                 r15, r0,  25            ; store coefficient
addui.eop           r29, r1,  20            ; store next IPK location

% Store Y, compute U
addui               r13, r13, 16            ; r13 = Y
stb                 r13, r10, 0      > 2    ; store Y
fetch               r1,  80
ori                 r13, r0,  -38           ; store coefficient
ori                 r14, r0,  -74           ; store coefficient
ori                 r15, r0,  112           ; store coefficient
addui.eop           r29, r1,  28            ; store next IPK location

% Store U, compute V
addui               r13, r13, 128           ; r13 = U
stb                 r13, r11, 0      > 2    ; store U
fetch               r1,  52
ori                 r13, r0,  112           ; store coefficient
ori                 r14, r0,  -94           ; store coefficient
ori                 r15, r0,  -18           ; store coefficient
addui.eop           r29, r1,  28            ; store next IPK location

% Store V, loop if necessary
addui               r13, r13, 128           ; r13 = V
stb                 r13, r12, 0      > 2    ; store V
addui               r10, r10, 1
setlt.p             r0,  r10, r4            ; see if we have finished
p?fetch             r1,  -112
nop.eop

% Subroutine to compute (xR + yG + zB + 128) >> 8
% Excludes final addition because I currently don't have enough registers for it.
% Assumes x is in r13, y is in r14, z is in r15 and next IPK address is in r29.
% Leaves result in r13.
mullw               r13, r13, r7            ; xR
mullw               r14, r14, r8            ; yG
mullw               r15, r15, r9            ; zB
fetch               r29, 0
addu                r13, r13, r14           ; xR + yG
addu                r13, r13, r15           ; xR + yG + zB
addui               r13, r13, 128           ; xR + yG + zB + 128
srli.eop            r13, r13, 8             ; (xR + yG + zB + 128) >> 8