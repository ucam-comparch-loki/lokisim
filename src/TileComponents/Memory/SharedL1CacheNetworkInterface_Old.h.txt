//-------------------------------------------------------------------------------------------------
// Loki Project
// Software Simulator for Design Space Exploration
//-------------------------------------------------------------------------------------------------
// Shared L1 Cache Network Interface Definition
//-------------------------------------------------------------------------------------------------
// Defines the interface logic between the on-chip network and the crossbar switch.
//
// Inputs from the network are buffered in input queues and therefore implicitly registered.
// All output ports to the crossbar switch are registered as well.
//
// Protocol for communicating with a memory (currently identical to the old system):
//  1. Claim a port in the usual way (invisible to the programmer/compiler).
//     This is currently done automatically whenever setchmap is executed.
//  2. Send a MemoryRequest to that port, specifying the channel ID to send
//     results to, and saying that the MemoryRequest is to set up a connection:
//     MemoryRequest(channel id, MemoryRequest::SETUP);
//  3. Use the load and store instructions to send addresses/data to the
//     memory.
//-------------------------------------------------------------------------------------------------
// File:       SharedL1CacheNetworkInterface.h
// Author:     Andreas Koltes (andreas.koltes@cl.cam.ac.uk)
// Created on: 11/01/2011
//-------------------------------------------------------------------------------------------------

#ifndef SHAREDL1CACHENETWORKINTERFACE_H_
#define SHAREDL1CACHENETWORKINTERFACE_H_

#include "TileComponent.h"
#include "../Memory/AddressedStorage.h"
#include "../Memory/BufferArray.h"

class SharedL1CacheNetworkInterface : public TileComponent {
	//---------------------------------------------------------------------------------------------
	// Ports
	//---------------------------------------------------------------------------------------------

public:

	// Network ports inherited from TileComponent

	/*
	sc_in<bool>				clock;					// Clock

	sc_in<Word>				*in;					// All inputs to the component. There should be NUM_CLUSTER_INPUTS of them.
	sc_out<AddressedWord>	*out;					// All outputs of the component. There should be NUM_CLUSTER_OUTPUTS of them.

	sc_in<bool>				*flowControlIn;			// A flow control signal for each output (NUM_CLUSTER_OUTPUTS).
	sc_out<int>				*flowControlOut;		// A flow control signal for each input (NUM_CLUSTER_INPUTS). Each one tells how much space is remaining in a particular input buffer.

	sc_out<bool>			idle;					// Signal that this component is not currently doing any work.
	*/

	// Internal ports to L1 cache system

	sc_out<uint32_t>		*oAddress;				// Addresses sent to crossbar switch (one per channel)
	sc_out<uint32_t>		*oData;					// Data words sent to crossbar switch (one per channel)
	sc_out<uint8_t>			*oByteMask;				// Byte mask sent to crossbar switch (one per channel)
	sc_out<bool>			*oReadEnable;			// Read enable signals to crossbar switch (one per channel)
	sc_out<bool>			*oWriteEnable;			// Write enable signals to crossbar switch (one per channel)

	sc_in<uint32_t>			*iData;					// Data words arriving from crossbar switch (one per channel)
	sc_in<bool>				*iAcknowledge;			// Acknowledgement signals arriving from the crossbar switch (one per channel)

	//---------------------------------------------------------------------------------------------
	// Configuration parameters
	//---------------------------------------------------------------------------------------------

private:

	uint					cChannels;				// Number of channels

	//---------------------------------------------------------------------------------------------
	// Utility definitions
	//---------------------------------------------------------------------------------------------

private:

	static const int INVALID = -1;

	enum MemoryOperation {
		OPERATION_NONE,
		OPERATION_LOAD,
		OPERATION_LOADBYTE,
		OPERATION_STORE,
		OPERATION_STOREBYTE
	};

	struct ConnectionState {
	public:
		int RemoteChannel;
		int Address;
		MemoryOperation Operation;
		bool Streaming;
		bool AccessPending;
		int ShiftCount;
	};

	//---------------------------------------------------------------------------------------------
	// Registers
	//---------------------------------------------------------------------------------------------

private:

	ConnectionState			*rConnections;			// Connection status for each channel to the network
	BufferArray<Word>		rRequestQueues;			// Request queue for each channel to the network

	//---------------------------------------------------------------------------------------------
	// Event handlers / Processes
	//---------------------------------------------------------------------------------------------

private:

	// Method which is called at the beginning of each clock cycle

	void processNewCycle();

	// Check all input ports for new data, and put it into the buffers

	void processInputChanged();

	//---------------------------------------------------------------------------------------------
	// Constructors / Destructors
	//---------------------------------------------------------------------------------------------

public:

	SC_HAS_PROCESS(SharedL1CacheNetworkInterface);
	SharedL1CacheNetworkInterface(sc_module_name name, ComponentID id, uint channels, uint queueDepth);
	virtual ~SharedL1CacheNetworkInterface();

	//---------------------------------------------------------------------------------------------
	// Simulation utility methods inherited from TileComponent - not part of simulated logic
	//---------------------------------------------------------------------------------------------

public:

	// The area of this component in square micrometres

	virtual double area() const;

	// The energy consumed by this component in picojoules

	virtual double energy() const;

	// Initialise the contents of this memory to the Words in the given vector

	virtual void storeData(std::vector<Word>& data, MemoryAddr location = 0);

	// Print the contents of this memory

	virtual void print(MemoryAddr start = 0, MemoryAddr end = MEMORY_SIZE) const;

	// Return the value at the given address

	virtual Word getMemVal(MemoryAddr addr) const;
};

#endif /* SHAREDL1CACHENETWORKINTERFACE_H_ */
